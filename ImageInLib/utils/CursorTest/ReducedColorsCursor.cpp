#include "stdafx.h"
#include "ReducedColorsCursor.h"
#include <memory>


static const RGBQUAD g_VGA16[16] =
{
    {  0,    0,    0,    },  // Black
    {  0,    0,    0x80  },  // Dark Red
    {  0,    0x80, 0,    },  // Dark Green
    {  0,    0x80, 0x80  },  // Dark Yellow
    {  0x80, 0,    0,    },  // Dark Blue
    {  0x80, 0,    0x80  },  // Dark Magenta
    {  0x80, 0x80, 0,    },  // Dark Cyan
    {  0x80, 0x80, 0x80  },  // Gray 50%
    {  0xC0, 0xC0, 0xC0  },  // Gray 75%
    {  0,    0,    0xFF  },  // Red
    {  0,    0xFF, 0,    },  // Green
    {  0,    0xFF, 0xFF  },  // Yellow
    {  0xFF, 0,    0,    },  // Blue
    {  0xFF, 0,    0xFF  },  // Magenta
    {  0xFF, 0xFF, 0,    },  // Cyan
    {  0xFF, 0xFF, 0xFF  }   // White
};

static const RGBQUAD g_VGA256[256] =
{
	{ 0x00, 0x00, 0xFF, 0x00 }, { 0x00, 0xFF, 0x00, 0x00 }, { 0xFF, 0x00, 0x00, 0x00 }, { 0x00, 0xFF, 0xFF, 0x00 },
	{ 0xFF, 0xFF, 0x00, 0x00 }, { 0xFF, 0x00, 0xFF, 0x00 }, { 0xC0, 0xC0, 0xC0, 0x00 }, { 0xFF, 0xF8, 0xF0, 0x00 },
	{ 0xD7, 0xEB, 0xFA, 0x00 }, { 0xD4, 0xFF, 0x7F, 0x00 }, { 0xFF, 0x00, 0x00, 0x00 }, { 0xE2, 0x2B, 0x8A, 0x00 },
	{ 0x2A, 0x2A, 0xA5, 0x00 }, { 0x00, 0x00, 0x00, 0x00 }, { 0x04, 0x04, 0x04, 0x00 }, { 0x08, 0x08, 0x08, 0x00 },
	{ 0x0C, 0x0C, 0x0C, 0x00 }, { 0x11, 0x11, 0x11, 0x00 }, { 0x16, 0x16, 0x16, 0x00 }, { 0x1C, 0x1C, 0x1C, 0x00 },
	{ 0x22, 0x22, 0x22, 0x00 }, { 0x29, 0x29, 0x29, 0x00 }, { 0x33, 0x33, 0x33, 0x00 }, { 0x39, 0x39, 0x39, 0x00 },
	{ 0x42, 0x42, 0x42, 0x00 }, { 0x4D, 0x4D, 0x4D, 0x00 }, { 0x55, 0x55, 0x55, 0x00 }, { 0x60, 0x60, 0x60, 0x00 },
	{ 0x66, 0x66, 0x66, 0x00 }, { 0x70, 0x70, 0x70, 0x00 }, { 0x80, 0x80, 0x80, 0x00 }, { 0x8C, 0x8C, 0x8C, 0x00 },
	{ 0x94, 0x94, 0x94, 0x00 }, { 0x99, 0x99, 0x99, 0x00 }, { 0xA4, 0xA4, 0xA4, 0x00 }, { 0xAC, 0xAC, 0xAC, 0x00 },
	{ 0xB6, 0xB6, 0xB6, 0x00 }, { 0xC0, 0xC0, 0xC0, 0x00 }, { 0xCC, 0xCC, 0xCC, 0x00 }, { 0xD4, 0xD4, 0xD4, 0x00 },
	{ 0xDA, 0xDA, 0xDA, 0x00 }, { 0xE0, 0xE0, 0xE0, 0x00 }, { 0xEC, 0xEC, 0xEC, 0x00 }, { 0xF8, 0xF8, 0xF8, 0x00 },
	{ 0xFB, 0xFB, 0xFB, 0x00 }, { 0xFF, 0xFF, 0xFF, 0x00 }, { 0x33, 0x00, 0x00, 0x00 }, { 0x66, 0x00, 0x00, 0x00 },
	{ 0x99, 0x00, 0x00, 0x00 }, { 0xCC, 0x00, 0x00, 0x00 }, { 0xFF, 0x00, 0x00, 0x00 }, { 0x00, 0x33, 0x00, 0x00 },
	{ 0x33, 0x33, 0x00, 0x00 }, { 0x66, 0x33, 0x00, 0x00 }, { 0x99, 0x33, 0x00, 0x00 }, { 0xCC, 0x33, 0x00, 0x00 },
	{ 0xFF, 0x33, 0x00, 0x00 }, { 0x00, 0x66, 0x00, 0x00 }, { 0x33, 0x66, 0x00, 0x00 }, { 0x66, 0x66, 0x00, 0x00 },
	{ 0x99, 0x66, 0x00, 0x00 }, { 0xCC, 0x66, 0x00, 0x00 }, { 0xFF, 0x66, 0x00, 0x00 }, { 0x00, 0x99, 0x00, 0x00 },
	{ 0x33, 0x99, 0x00, 0x00 }, { 0x66, 0x99, 0x00, 0x00 }, { 0x99, 0x99, 0x00, 0x00 }, { 0xCC, 0x99, 0x00, 0x00 },
	{ 0xFF, 0x99, 0x00, 0x00 }, { 0x00, 0xCC, 0x00, 0x00 }, { 0x33, 0xCC, 0x00, 0x00 }, { 0x66, 0xCC, 0x00, 0x00 },
	{ 0x99, 0xCC, 0x00, 0x00 }, { 0xCC, 0xCC, 0x00, 0x00 }, { 0xFF, 0xCC, 0x00, 0x00 }, { 0x00, 0xFF, 0x00, 0x00 },
	{ 0x33, 0xFF, 0x00, 0x00 }, { 0x66, 0xFF, 0x00, 0x00 }, { 0x99, 0xFF, 0x00, 0x00 }, { 0xCC, 0xFF, 0x00, 0x00 },
	{ 0xFF, 0xFF, 0x00, 0x00 }, { 0x00, 0x00, 0x33, 0x00 }, { 0x33, 0x00, 0x33, 0x00 }, { 0x66, 0x00, 0x33, 0x00 },
	{ 0x99, 0x00, 0x33, 0x00 }, { 0xCC, 0x00, 0x33, 0x00 }, { 0xFF, 0x00, 0x33, 0x00 }, { 0x00, 0x33, 0x33, 0x00 },
	{ 0x66, 0x33, 0x33, 0x00 }, { 0x99, 0x33, 0x33, 0x00 }, { 0xCC, 0x33, 0x33, 0x00 }, { 0xFF, 0x33, 0x33, 0x00 },
	{ 0x00, 0x66, 0x33, 0x00 }, { 0x33, 0x66, 0x33, 0x00 }, { 0x66, 0x66, 0x33, 0x00 }, { 0x99, 0x66, 0x33, 0x00 },
	{ 0xCC, 0x66, 0x33, 0x00 }, { 0xFF, 0x66, 0x33, 0x00 }, { 0x00, 0x99, 0x33, 0x00 }, { 0x33, 0x99, 0x33, 0x00 },
	{ 0x66, 0x99, 0x33, 0x00 }, { 0x99, 0x99, 0x33, 0x00 }, { 0xCC, 0x99, 0x33, 0x00 }, { 0xFF, 0x99, 0x33, 0x00 },
	{ 0x00, 0xCC, 0x33, 0x00 }, { 0x33, 0xCC, 0x33, 0x00 }, { 0x66, 0xCC, 0x33, 0x00 }, { 0x99, 0xCC, 0x33, 0x00 },
	{ 0xCC, 0xCC, 0x33, 0x00 }, { 0xFF, 0xCC, 0x33, 0x00 }, { 0x00, 0xFF, 0x33, 0x00 }, { 0x33, 0xFF, 0x33, 0x00 },
	{ 0x66, 0xFF, 0x33, 0x00 }, { 0x99, 0xFF, 0x33, 0x00 }, { 0xCC, 0xFF, 0x33, 0x00 }, { 0xFF, 0xFF, 0x33, 0x00 },
	{ 0x00, 0x00, 0x66, 0x00 }, { 0x33, 0x00, 0x66, 0x00 }, { 0x66, 0x00, 0x66, 0x00 }, { 0x99, 0x00, 0x66, 0x00 },
	{ 0xCC, 0x00, 0x66, 0x00 }, { 0xFF, 0x00, 0x66, 0x00 }, { 0x00, 0x33, 0x66, 0x00 }, { 0x33, 0x33, 0x66, 0x00 },
	{ 0x66, 0x33, 0x66, 0x00 }, { 0x99, 0x33, 0x66, 0x00 }, { 0xCC, 0x33, 0x66, 0x00 }, { 0xFF, 0x33, 0x66, 0x00 },
	{ 0x00, 0x66, 0x66, 0x00 }, { 0x33, 0x66, 0x66, 0x00 }, { 0x99, 0x66, 0x66, 0x00 }, { 0xCC, 0x66, 0x66, 0x00 },
	{ 0xFF, 0x66, 0x66, 0x00 }, { 0x00, 0x99, 0x66, 0x00 }, { 0x33, 0x99, 0x66, 0x00 }, { 0x66, 0x99, 0x66, 0x00 },
	{ 0x99, 0x99, 0x66, 0x00 }, { 0xCC, 0x99, 0x66, 0x00 }, { 0xFF, 0x99, 0x66, 0x00 }, { 0x00, 0xCC, 0x66, 0x00 },
	{ 0x33, 0xCC, 0x66, 0x00 }, { 0x66, 0xCC, 0x66, 0x00 }, { 0x99, 0xCC, 0x66, 0x00 }, { 0xCC, 0xCC, 0x66, 0x00 },
	{ 0xFF, 0xCC, 0x66, 0x00 }, { 0x00, 0xFF, 0x66, 0x00 }, { 0x33, 0xFF, 0x66, 0x00 }, { 0x66, 0xFF, 0x66, 0x00 },
	{ 0x99, 0xFF, 0x66, 0x00 }, { 0xCC, 0xFF, 0x66, 0x00 }, { 0xFF, 0xFF, 0x66, 0x00 }, { 0x00, 0x00, 0x99, 0x00 },
	{ 0x33, 0x00, 0x99, 0x00 }, { 0x66, 0x00, 0x99, 0x00 }, { 0x99, 0x00, 0x99, 0x00 }, { 0xCC, 0x00, 0x99, 0x00 },
	{ 0xFF, 0x00, 0x99, 0x00 }, { 0x00, 0x33, 0x99, 0x00 }, { 0x33, 0x33, 0x99, 0x00 }, { 0x66, 0x33, 0x99, 0x00 },
	{ 0x99, 0x33, 0x99, 0x00 }, { 0xCC, 0x33, 0x99, 0x00 }, { 0xFF, 0x33, 0x99, 0x00 }, { 0x00, 0x66, 0x99, 0x00 },
	{ 0x33, 0x66, 0x99, 0x00 }, { 0x66, 0x66, 0x99, 0x00 }, { 0x99, 0x66, 0x99, 0x00 }, { 0xCC, 0x66, 0x99, 0x00 },
	{ 0xFF, 0x66, 0x99, 0x00 }, { 0x00, 0x99, 0x99, 0x00 }, { 0x33, 0x99, 0x99, 0x00 }, { 0x66, 0x99, 0x99, 0x00 },
	{ 0xCC, 0x99, 0x99, 0x00 }, { 0xFF, 0x99, 0x99, 0x00 }, { 0x01, 0xCC, 0x99, 0x00 }, { 0x33, 0xCC, 0x99, 0x00 },
	{ 0x66, 0xCC, 0x99, 0x00 }, { 0x99, 0xCC, 0x99, 0x00 }, { 0xCC, 0xCC, 0x99, 0x00 }, { 0xFF, 0xCC, 0x99, 0x00 },
	{ 0x00, 0xFF, 0x99, 0x00 }, { 0x33, 0xFF, 0x99, 0x00 }, { 0x66, 0xFF, 0x99, 0x00 }, { 0x99, 0xFF, 0x99, 0x00 },
	{ 0xCC, 0xFF, 0x99, 0x00 }, { 0xFF, 0xFF, 0x99, 0x00 }, { 0x00, 0x00, 0xCC, 0x00 }, { 0x33, 0x00, 0xCC, 0x00 },
	{ 0x66, 0x00, 0xCC, 0x00 }, { 0x99, 0x00, 0xCC, 0x00 }, { 0xCC, 0x00, 0xCC, 0x00 }, { 0xFF, 0x00, 0xCC, 0x00 },
	{ 0x00, 0x33, 0xCC, 0x00 }, { 0x33, 0x33, 0xCC, 0x00 }, { 0x66, 0x33, 0xCC, 0x00 }, { 0x99, 0x33, 0xCC, 0x00 },
	{ 0xCC, 0x33, 0xCC, 0x00 }, { 0xFF, 0x33, 0xCC, 0x00 }, { 0x00, 0x66, 0xCC, 0x00 }, { 0x33, 0x66, 0xCC, 0x00 },
	{ 0x66, 0x66, 0xCC, 0x00 }, { 0x99, 0x66, 0xCC, 0x00 }, { 0xCC, 0x66, 0xCC, 0x00 }, { 0xFF, 0x66, 0xCC, 0x00 },
	{ 0x00, 0x99, 0xCC, 0x00 }, { 0x33, 0x99, 0xCC, 0x00 }, { 0x66, 0x99, 0xCC, 0x00 }, { 0x99, 0x99, 0xCC, 0x00 },
	{ 0xCC, 0x99, 0xCC, 0x00 }, { 0xFF, 0x99, 0xCC, 0x00 }, { 0x00, 0xCC, 0xCC, 0x00 }, { 0x33, 0xCC, 0xCC, 0x00 },
	{ 0x66, 0xCC, 0xCC, 0x00 }, { 0x99, 0xCC, 0xCC, 0x00 }, { 0xFF, 0xCC, 0xCC, 0x00 }, { 0x00, 0xFF, 0xCC, 0x00 },
	{ 0x33, 0xFF, 0xCC, 0x00 }, { 0x66, 0xFF, 0xCC, 0x00 }, { 0x99, 0xFF, 0xCC, 0x00 }, { 0xCC, 0xFF, 0xCC, 0x00 },
	{ 0xFF, 0xFF, 0xCC, 0x00 }, { 0x00, 0x00, 0xFF, 0x00 }, { 0x33, 0x00, 0xFF, 0x00 }, { 0x66, 0x00, 0xFF, 0x00 },
	{ 0x99, 0x00, 0xFF, 0x00 }, { 0xCC, 0x00, 0xFF, 0x00 }, { 0xFF, 0x00, 0xFF, 0x00 }, { 0x00, 0x33, 0xFF, 0x00 },
	{ 0x33, 0x33, 0xFF, 0x00 }, { 0x66, 0x33, 0xFF, 0x00 }, { 0x99, 0x33, 0xFF, 0x00 }, { 0xCC, 0x33, 0xFF, 0x00 },
	{ 0xFF, 0x33, 0xFF, 0x00 }, { 0x00, 0x66, 0xFF, 0x00 }, { 0x33, 0x66, 0xFF, 0x00 }, { 0x66, 0x66, 0xFF, 0x00 },
	{ 0x99, 0x66, 0xFF, 0x00 }, { 0xCC, 0x66, 0xFF, 0x00 }, { 0xFF, 0x66, 0xFF, 0x00 }, { 0x00, 0x99, 0xFF, 0x00 },
	{ 0x33, 0x99, 0xFF, 0x00 }, { 0x66, 0x99, 0xFF, 0x00 }, { 0x99, 0x99, 0xFF, 0x00 }, { 0xCC, 0x99, 0xFF, 0x00 },
	{ 0xFF, 0x99, 0xFF, 0x00 }, { 0x00, 0xCC, 0xFF, 0x00 }, { 0x33, 0xCC, 0xFF, 0x00 }, { 0x66, 0xCC, 0xFF, 0x00 },
	{ 0x99, 0xCC, 0xFF, 0x00 }, { 0xCC, 0xCC, 0xFF, 0x00 }, { 0xFF, 0xCC, 0xFF, 0x00 }, { 0x00, 0xFF, 0xFF, 0x00 },
	{ 0x33, 0xFF, 0xFF, 0x00 }, { 0x66, 0xFF, 0xFF, 0x00 }, { 0x99, 0xFF, 0xFF, 0x00 }, { 0xCC, 0xFF, 0xFF, 0x00 }
};


BYTE GetNearestColorIndex(COLORREF color, const RGBQUAD *palette, size_t paletteColors)
{
	RGBQUAD rgbColor = { GetRValue(color), GetGValue(color), GetBValue(color), 0 };

	const RGBQUAD * palBest = palette;
	const RGBQUAD * palTemp = palette;
	const RGBQUAD * palMax = palette + paletteColors;
    ULONG errBest = 0xffffffff;
    do
    {
		ULONG errBlue = palTemp->rgbBlue - rgbColor.rgbBlue;
		ULONG errGreen = palTemp->rgbGreen - rgbColor.rgbGreen;
		ULONG errRed = palTemp->rgbRed - rgbColor.rgbRed;
		ULONG errTemp = errBlue * errBlue + errGreen * errGreen + errRed * errRed;
        if (errTemp < errBest)
        {
            palBest = palTemp;
			errBest = errTemp;
            if (errBest == 0)
                break;
        }
    } while (++palTemp < palMax);

	return palBest - palette;
}

static void ConvertCursor_1bit(const BITMAP & colorBmp, const BITMAP & maskBmp)
{
	BYTE * xorMask = (BYTE*)maskBmp.bmBits + maskBmp.bmWidthBytes * maskBmp.bmHeight / 2;
	ASSERT(colorBmp.bmHeight * 2 == maskBmp.bmHeight);
	memset(xorMask, 0, maskBmp.bmWidthBytes * maskBmp.bmHeight / 2);
	for (int y = 0; y < colorBmp.bmHeight; ++y)
	{
		COLORREF * color = (COLORREF *)((BYTE*)colorBmp.bmBits + y * colorBmp.bmWidthBytes);
		BYTE * xor = xorMask + y * maskBmp.bmWidthBytes;
		for (int x = 0; x < colorBmp.bmWidth; ++x, ++color)
		{
			if (GetRValue(*color) > 160 || GetGValue(*color) > 160 || GetBValue(*color) > 160 ||
				GetRValue(*color) + GetGValue(*color) + GetBValue(*color) >= 3*128)
				xor[x/8] |= 128 >> (x & 7);
		}
	}
}

static void ConvertCursor_4bit(const BITMAP & colorBmp, const BITMAP & newColorBmp)
{
	for (int y = 0; y < colorBmp.bmHeight; ++y)
	{
		COLORREF * color = (COLORREF *)((BYTE*)colorBmp.bmBits + y * colorBmp.bmWidthBytes);
		BYTE * newColor = (BYTE*)newColorBmp.bmBits + y * newColorBmp.bmWidthBytes;
		for (int x = 0; x < colorBmp.bmWidth; ++x, ++color)
		{
			BYTE colorIdx = GetNearestColorIndex(*color, g_VGA16, _countof(g_VGA16));
			if (x & 1)
				newColor[x/2] |= colorIdx;
			else
				newColor[x/2] = colorIdx << 4;
		}
	}
}

static void ConvertCursor_8bit(const BITMAP & colorBmp, const BITMAP & newColorBmp)
{
	for (int y = 0; y < colorBmp.bmHeight; ++y)
	{
		COLORREF * color = (COLORREF *)((BYTE*)colorBmp.bmBits + y * colorBmp.bmWidthBytes);
		BYTE * newColor = (BYTE*)newColorBmp.bmBits + y * newColorBmp.bmWidthBytes;
		for (int x = 0; x < colorBmp.bmWidth; ++x, ++color)
		{
			BYTE colorIdx = GetNearestColorIndex(*color, g_VGA256, _countof(g_VGA256));
			newColor[x] = colorIdx;
		}
	}
}

static void ConvertCursor_24bit(const BITMAP & colorBmp, const BITMAP & newColorBmp)
{
	for (int y = 0; y < colorBmp.bmHeight; ++y)
	{
		COLORREF * color = (COLORREF *)((BYTE*)colorBmp.bmBits + y * colorBmp.bmWidthBytes);
		BYTE * newColor = (BYTE*)newColorBmp.bmBits + y * newColorBmp.bmWidthBytes;
		for (int x = 0; x < colorBmp.bmWidth; ++x, ++color)
		{
			*newColor++ = GetRValue(*color);
			*newColor++ = GetGValue(*color);
			*newColor++ = GetBValue(*color);
		}
	}
}


static HBITMAP CreateBitmap(const BITMAP & colorBmp, BITMAP & newColorBmp, int bits)
{
#pragma pack(push,1)
	struct {
		BITMAPINFOHEADER    bmiHeader;
		RGBQUAD             bmiColors[256];
	} bmi;
#pragma pack(pop)
	HBITMAP hBitmap;
	BYTE *bmBits;
	HDC hMemDC;

	HDC hScreenDC = ::GetDC(NULL);
	hMemDC = ::CreateCompatibleDC(hScreenDC);
	::ReleaseDC(NULL, hScreenDC);

	memset(&bmi, 0, sizeof(bmi));
	bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
	bmi.bmiHeader.biWidth = colorBmp.bmWidth;
	bmi.bmiHeader.biHeight = -colorBmp.bmHeight;
	bmi.bmiHeader.biPlanes = 1;
	bmi.bmiHeader.biBitCount = bits;
	bmi.bmiHeader.biCompression = BI_RGB;
	bmi.bmiHeader.biSizeImage = 0;
	bmi.bmiHeader.biXPelsPerMeter = 0;
	bmi.bmiHeader.biYPelsPerMeter = 0;
	bmi.bmiHeader.biClrUsed = (bits <= 8) ? 1 << bits : 0;
	bmi.bmiHeader.biClrImportant = 0;

	if (bits == 4)
		memcpy(bmi.bmiColors, g_VGA16, sizeof(g_VGA16));
	else if (bits == 8)
		memcpy(bmi.bmiColors, g_VGA256, sizeof(g_VGA256));

	bmBits = NULL;
	hBitmap = ::CreateDIBSection(hMemDC, (BITMAPINFO*)&bmi, DIB_RGB_COLORS, (void **)&bmBits, NULL, NULL); 
	memset(bmBits, 0, ((((colorBmp.bmWidth * bits) + 31) & ~31) >> 3) * colorBmp.bmHeight);
	::ReleaseDC(NULL, hMemDC);

	newColorBmp = colorBmp;
	newColorBmp.bmBitsPixel = bits;
	newColorBmp.bmWidthBytes = (((newColorBmp.bmWidth * bits) + 31) & ~31) >> 3;
	newColorBmp.bmBits = bmBits;

	return hBitmap;
}


mutex ReducedColorsCursor::m_cursorsLock;
std::map<UINT, ReducedColorsCursor::CURSOR_INFO> ReducedColorsCursor::m_cursors1BPP;
std::map<UINT, ReducedColorsCursor::CURSOR_INFO> ReducedColorsCursor::m_cursors4BPP;
std::map<UINT, ReducedColorsCursor::CURSOR_INFO> ReducedColorsCursor::m_cursors8BPP;
std::map<UINT, ReducedColorsCursor::CURSOR_INFO> ReducedColorsCursor::m_cursors24BPP;


HCURSOR ReducedColorsCursor::LoadCursor(UINT nIDResource, int cursorBits)
{
	HCURSOR hCursor = AfxGetApp()->LoadCursor(nIDResource);

	if (cursorBits != 1 && cursorBits != 4 && cursorBits != 8 && cursorBits != 24)
		return hCursor;

	std::map<UINT, CURSOR_INFO> & cursors = 
		(cursorBits == 1) ? m_cursors1BPP : 
		(cursorBits == 4) ? m_cursors4BPP : 
		(cursorBits == 8) ? m_cursors8BPP : 
							m_cursors24BPP;
	{
		mutex_lock l(m_cursorsLock);
		auto itCursor = cursors.find(nIDResource);
		if (itCursor != cursors.end())
			return itCursor->second.m_hCursor;
	}

	HCURSOR hNewCursor = NULL;
    ICONINFO iconinfo;
    BITMAP maskBmp;
	DWORD maskSize;
    std::unique_ptr<BYTE> maskBits;
	HBITMAP hbmMask = NULL;
    BITMAP colorBmp;
	DWORD colorsSize;
    std::unique_ptr<BYTE> colorBits;
	HBITMAP hbmColor = NULL;

    if (!GetIconInfo(hCursor, &iconinfo))
		return hCursor;

    if (!iconinfo.hbmColor)
	{
		// not a 32-bit cursor
		if (iconinfo.hbmMask)
			DeleteObject(iconinfo.hbmMask);
		return hCursor;
	}

    if (!::GetObject(iconinfo.hbmMask, sizeof(maskBmp), (LPSTR)&maskBmp))
	{
		if (iconinfo.hbmColor)
			DeleteObject(iconinfo.hbmColor);
		if (iconinfo.hbmMask)
			DeleteObject(iconinfo.hbmMask);
		return hCursor;
	}

    if (!::GetObject(iconinfo.hbmColor, sizeof(colorBmp), (LPSTR)&colorBmp))
	{
		if (iconinfo.hbmColor)
			DeleteObject(iconinfo.hbmColor);
		if (iconinfo.hbmMask)
			DeleteObject(iconinfo.hbmMask);
		return hCursor;
	}
	if (colorBmp.bmPlanes != 1 || colorBmp.bmBitsPixel != 32)
	{
		// not a 32-bit cursor
		if (iconinfo.hbmColor)
			DeleteObject(iconinfo.hbmColor);
		if (iconinfo.hbmMask)
			DeleteObject(iconinfo.hbmMask);
		return hCursor;
	}

	maskSize = maskBmp.bmWidthBytes * maskBmp.bmHeight;
	maskBits.reset(new BYTE[maskSize]);
	maskBmp.bmBits = maskBits.get();
	if (!maskBits)
	{
		if (iconinfo.hbmColor)
			DeleteObject(iconinfo.hbmColor);
		if (iconinfo.hbmMask)
			DeleteObject(iconinfo.hbmMask);
		return hCursor;
	}
    if (!GetBitmapBits(iconinfo.hbmMask, maskSize, maskBits.get()))
	{
		if (iconinfo.hbmColor)
			DeleteObject(iconinfo.hbmColor);
		if (iconinfo.hbmMask)
			DeleteObject(iconinfo.hbmMask);
		return hCursor;
	}

	colorsSize = colorBmp.bmWidthBytes * colorBmp.bmHeight;
	colorBits.reset(new BYTE[colorsSize]);
	colorBmp.bmBits = colorBits.get();
	if (!colorBits)
	{
		if (iconinfo.hbmColor)
			DeleteObject(iconinfo.hbmColor);
		if (iconinfo.hbmMask)
			DeleteObject(iconinfo.hbmMask);
		return hCursor;
	}
	if (!GetBitmapBits(iconinfo.hbmColor, colorsSize, colorBits.get()))
	{
		if (iconinfo.hbmColor)
			DeleteObject(iconinfo.hbmColor);
		if (iconinfo.hbmMask)
			DeleteObject(iconinfo.hbmMask);
		return hCursor;
	}

	if (iconinfo.hbmColor)
		DeleteObject(iconinfo.hbmColor);
	if (iconinfo.hbmMask)
		DeleteObject(iconinfo.hbmMask);

	if (cursorBits == 1)
	{
		maskBmp.bmHeight *= 2;
		std::unique_ptr<BYTE> newMaskBits(new BYTE[maskBmp.bmWidthBytes * maskBmp.bmHeight]);
		if (!newMaskBits)
			return hCursor;
		memcpy(newMaskBits.get(), maskBits.get(), maskSize);
		maskBmp.bmBits = newMaskBits.get();
		maskBits.swap(newMaskBits);
		ConvertCursor_1bit(colorBmp, maskBmp);
	}
	else if (cursorBits == 4)
	{
	    BITMAP newColorBmp;
		hbmColor = CreateBitmap(colorBmp, newColorBmp, 4);
		if (!hbmColor)
			return hCursor;
		ConvertCursor_4bit(colorBmp, newColorBmp);
	}
	else if (cursorBits == 8)
	{
	    BITMAP newColorBmp;
		hbmColor = CreateBitmap(colorBmp, newColorBmp, 8);
		if (!hbmColor)
			return hCursor;
		ConvertCursor_8bit(colorBmp, newColorBmp);
	}
	else if (cursorBits == 24)
	{
	    BITMAP newColorBmp;
		hbmColor = CreateBitmap(colorBmp, newColorBmp, 24);
		if (!hbmColor)
			return hCursor;
		ConvertCursor_24bit(colorBmp, newColorBmp);
	}

	hbmMask = CreateBitmapIndirect(&maskBmp);
	if (!hbmMask)
	{
		if (hbmColor)
			DeleteObject(hbmColor);
		return hCursor;
	}

	iconinfo.hbmMask = hbmMask;
	iconinfo.hbmColor = hbmColor;
	hNewCursor = CreateIconIndirect(&iconinfo);
	if (!hNewCursor)
	{
		DeleteObject(hbmMask);
		if (hbmColor)
			DeleteObject(hbmColor);
		return hCursor;
	}

	{
		mutex_lock l(m_cursorsLock);
		auto itCursor = cursors.find(nIDResource);
		if (itCursor != cursors.end() && itCursor->second.m_hCursor)
		{
			DeleteObject(hbmMask);
			if (hbmColor)
				DeleteObject(hbmColor);
			DestroyCursor(hNewCursor);
			return itCursor->second.m_hCursor;
		}
		cursors[nIDResource].m_hCursor = hNewCursor;
		cursors[nIDResource].m_hbmMask = hbmMask;
		cursors[nIDResource].m_hbmColor = hbmColor;
	}
	return hNewCursor;
}
